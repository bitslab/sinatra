(window.webpackJsonp = window.webpackJsonp || []).push([[176], {
    "3AAD": function (t, e, i) {
        "use strict";
        const s = {...i("7n04").a, pinToNewestWhenAtNewest: !0};
        e.a = s
    }, "64vW": function (t, e, i) {
        "use strict";
        var s = i("ERkP");
        const o = i.n(s).a.createContext({heightsReady: !0});
        e.a = o
    }, FwSR: function (t, e, i) {
        "use strict";
        i.r(e), i.d(e, "resetIsModalScrollerRendered", (function () {
            return wt
        })), i.d(e, "default", (function () {
            return vt
        }));
        i("kYxP");
        var s = i("ERkP"), o = i.n(s), n = i("aWzz"), r = i("7N4s"), h = i("zTrU"), a = i("+d3d"), d = i("fs1G"),
            c = i("0zXz"), l = i("OrGc"), m = i("oi7R"), _ = i("hACr"), u = i("uySD");
        const p = t => (e, i) => i.getTop() - e.getTop() <= t, g = t => (e, i) => e.getBottom() - i.getBottom() <= t,
            I = t => (e, i) => {
                const s = i.getHeight() * t;
                return i.getTop() - e.getTop() <= s
            }, f = t => (e, i) => {
                const s = i.getHeight() * t;
                return e.getBottom() - i.getBottom() <= s
            }, w = Object.freeze({INSIDE: "inside", OUTSIDE: "outside"}),
            v = (t, e, i, s) => ((t, e) => !t && e === w.INSIDE)(t, i) ? u.a.INITIAL_POSITION : ((t, e) => t === w.OUTSIDE && e === w.INSIDE)(t, i) ? u.a.MOVEMENT : ((t, e) => t === w.INSIDE && e === w.INSIDE)(t, i) && s !== e ? u.a.LIST_UPDATE : null;

        class b {
            constructor(t) {
                this._handlers = t.map((t => ({zone: t, state: {}})))
            }

            handlePositioningUpdate(t) {
                this._handlers.forEach((({state: e, zone: i}) => {
                    const {callback: s, condition: o} = i, {listLength: n, proximity: r} = e,
                        h = ((t, e) => t(e.getForList(), e.getForViewport()) ? w.INSIDE : w.OUTSIDE)(o, t),
                        a = t.getListLength(), d = v(r, n, h, a);
                    e.proximity = h, e.listLength = a, d && s({triggerCause: d})
                }))
            }
        }

        var R = i("ZIU7"), A = i("3AAD");
        const H = Object.freeze({FocusedItem: "focusedItem", Anchor: "anchor"});
        var T = t => ({anchor: t, type: H.Anchor}), y = t => ({itemId: t, type: H.FocusedItem}), S = i("z0MJ"),
            E = i.n(S), F = i("pQ3Z"), P = i.n(F), O = i("jHwr"), N = i("VY6S"), C = i("Qyxo"), x = i("qdp+"),
            V = i("/NU0"), M = i("6vUc"), B = i("jat/"), U = i("xN10"), j = i("Myq3"), L = i("mN6z"), D = i("aITJ"),
            W = i("iBK2"), z = i("v6aA"), k = i("6/RC");
        const K = new Set, q = new Set;
        let Y = !1;

        function $() {
            if (k.canUseDOM && !Y) {
                const t = ["fullscreenElement", "webkitFullscreenElement", "webkitCurrentFullScreenElement", "mozFullScreenElement", "msFullscreenElement"];
                ["webkitfullscreenchange", "mozfullscreenchange", "fullscreenchange", "msfullscreenchange"].forEach((e => {
                    document.addEventListener(e, (() => {
                        const e = t.map((t => document[t])).filter(Boolean)[0];
                        e ? K.forEach((t => t(e))) : q.forEach((t => t()))
                    }))
                }))
            }
            Y = !0
        }

        var J = i("E6XO"), G = i("c/W/"), Q = i("Irs7"), Z = i("gbD7"), X = i("OQ9W"), tt = i("38/B");
        var et = o.a.createContext({
            onAnimationStarted: () => {
            }, onAnimationEnded: () => {
            }, onHeightChanged: () => {
            }
        });
        const it = () => window.performance ? window.performance.now() : Date.now(), st = "transform 0.15s linear";

        class ot extends o.a.Component {
            constructor(t, e) {
                super(t, e), this._contentsFocusable = !1, this._perfReported = !1, this._shouldAnimateTranslate = !1, this._observeElement = t => {
                    X.a.observe(t, this._handleResize)
                }, this._handleResize = t => {
                    const {item: e, onHeightChanged: i} = this.props,
                        s = (t && Math.floor(t.contentRect.height)) !== (this._currentHeight && Math.floor(this._currentHeight));
                    t && s && (this._currentHeight = t.contentRect.height, i(e.id, t.contentRect.height)), this._recordTTFV()
                }, this._setRef = t => {
                    const {item: e, setAPI: i} = this.props;
                    t ? (this._element = t, i(e.id, this), this._observeElement(t)) : (i(e.id, void 0), this._element = void 0)
                }, this._setIsItemFocusable = t => {
                    this._contentsFocusable = t
                }, this._handleAnimationStarted = (t = st) => {
                    X.a.unobserveAll(this._element), this.props.onAnimationStarted(this.props.item.id, t), this._animationTTLTimeoutId && clearTimeout(this._animationTTLTimeoutId), this._animationTTLTimeoutId = setTimeout(this._handleAnimationEnded, 1e3)
                }, this._handleAnimationEnded = () => {
                    this._animationTTLTimeoutId && (clearTimeout(this._animationTTLTimeoutId), this._animationTTLTimeoutId = null), this._element && this._observeElement(this._element), this.props.onAnimationEnded(this.props.item.id)
                }, this._handleHeightChanged = t => {
                    this._currentHeight = t, this.props.onHeightChanged(this.props.item.id, t)
                }, this._animationContext = {
                    onAnimationEnded: this._handleAnimationEnded,
                    onAnimationStarted: this._handleAnimationStarted,
                    onHeightChanged: this._handleHeightChanged
                }, this._perfStart = it()
            }

            shouldComponentUpdate(t) {
                const {item: e, positioningStyle: i, shouldAnimate: s, visible: o} = this.props,
                    n = !Object(L.a)(t.positioningStyle, i);
                return this._shouldAnimateTranslate = n && t.visible === o, !Object(L.a)(t.item, e) || n || t.visible !== o || t.shouldAnimate !== s
            }

            componentWillUnmount() {
                this._animationTTLTimeoutId && (clearTimeout(this._animationTTLTimeoutId), this.props.onAnimationEnded(this.props.item.id)), X.a.unobserveAll(this._element)
            }

            componentDidUpdate(t) {
                const {item: e, setAPI: i} = this.props;
                t.item.id !== e.id && (i(t.item.id, void 0), i(e.id, this)), this._recordTTFV()
            }

            getElement() {
                return this._element
            }

            isFocusable() {
                return this._contentsFocusable
            }

            measureHeight() {
                return this._currentHeight || (this._currentHeight = this._element ? this._element.getBoundingClientRect().height : 0), this._currentHeight
            }

            render() {
                const {item: t, shouldAnimate: e, translationTransitionStyle: i, visible: s} = this.props,
                    n = this._shouldAnimateTranslate && !tt.a.reducedMotionEnabled ? i : "opacity 0.3s ease-out", r = {
                        ...this.props.positioningStyle,
                        position: "absolute",
                        opacity: s ? void 0 : .01,
                        width: "100%",
                        transition: e && !this._isAnimationDisabled ? n : void 0
                    };
                return o.a.createElement(et.Provider, {value: this._animationContext}, o.a.createElement("div", {
                    "data-testid": "cellInnerDiv",
                    ref: this._setRef,
                    style: r
                }, t.render(this._setIsItemFocusable)))
            }

            _recordTTFV() {
                const {item: t, onVisible: e, visible: i} = this.props;
                void 0 !== this._currentHeight && !this._perfReported && i && (e(t.id, it() - this._perfStart), this._perfReported = !0)
            }
        }

        ot.contextType = z.a, ot.defaultProps = {translationTransitionStyle: st};
        var nt = i("7nmT"), rt = i.n(nt), ht = i("zrc3");
        const at = t => {
            var e;
            return null == (e = t.find((t => t.focusable))) ? void 0 : e.id
        };

        class dt {
            constructor({listLength: t, listRect: e, renderedItems: i, viewportRect: s}) {
                this._viewportRect = s, this._listRect = e, this._listLength = t, this._renderedItems = i
            }

            getForList() {
                return this._listRect
            }

            getForViewport() {
                return this._viewportRect
            }

            getListLength() {
                return this._listLength
            }

            getRenderedItems() {
                return this._renderedItems
            }
        }

        var ct = i("64vW");

        class lt {
            constructor(t, e, i, s, o = 0) {
                this.itemId = t, this.offset = e, this.visible = i, this.canBeAnchor = s, this.height = o
            }

            getRectInViewport() {
                return new G.a(this.offset, this.height)
            }
        }

        const mt = {}, _t = ({cssPixels: t, dpr: e}) => Math.ceil(t * e) / e;

        class ut extends o.a.Component {
            constructor(t, e) {
                super(t, e), this._areAnchorsInvalidated = !1, this._cells = new Map, this._cellAnimations = new Set, this._cellAnimationStyle = st, this._currentHeadroom = 0, this._isFullScreened = !1, this._isIdle = !0, this._pendingHeightUpdates = new Map, this._previousScrollPosition = 0, this._renderedItemsStatus = new Set, this._rootRef = o.a.createRef(), this._slice = {
                    start: 0,
                    end: 0
                }, this._shouldScribeNextScroll = !0, this._visibilityMeasurements = new Map, this._handleScroll = () => {
                    this._wasPreviouslyAtNewestEnd = this.isAtNewest(), this._isInitialAnchoring || this._viewport.scrollY() < 0 || (this._isIdle = !1, this._updateScrollEnd(), this._scheduleCriticalUpdateThrottled())
                }, this._updateScrollEnd = Object(N.a)((() => {
                    const {analytics: t, onScrollEnd: e} = this.props,
                        i = this._viewport.scrollY() - this._previousScrollPosition;
                    this._previousScrollPosition = this._viewport.scrollY(), this._shouldScribeNextScroll && Math.abs(i) > 100 && t.scribe({
                        action: "scroll",
                        data: {event_value: i}
                    }), this._shouldScribeNextScroll = !0, this._isIdle = !0, e(), this._scheduleCriticalUpdate()
                }), 200), this._handleProgrammaticScroll = () => {
                    this._shouldScribeNextScroll = !1
                }, this._handleEnterFullscreen = () => {
                    this._isFullScreened = !0
                }, this._handleExitFullscreen = () => {
                    this._isFullScreened = !1, this._scheduleCriticalUpdate()
                }, this._getPositioningContext = Object(h.a)((t => ({heightsReady: t}))), this._getFinalRenderedItemsMemoized = Object(h.a)(((t, e) => {
                    const i = this._getItemMapMemoized(t);
                    return Object(C.a)(e, (t => {
                        const e = i.get(t.itemId);
                        return e && {item: e, offset: t.offset, visible: t.visible}
                    }))
                })), this._getItemMapMemoized = Object(h.a)((t => {
                    const e = new Map;
                    return t.forEach((t => {
                        e.set(t.id, t)
                    })), e
                })), this._getInitialRenderedItems = () => {
                    const {centerInitialAnchor: t, initialAnchor: e, list: i} = this.props, s = [];
                    if (!e) return s;
                    if (e.type === H.FocusedItem) {
                        let o = 0;
                        if (t) {
                            const t = this._getDocumentViewportHeight(), i = this._getHeightForItemId(e.itemId);
                            o = Math.ceil(t / 2) - i / 2
                        }
                        const n = Object(x.a)(i, (t => t.id === e.itemId ? new lt(t.id, o, !0, t.canBeAnchor) : void 0));
                        n && s.push(n)
                    } else if (e.type === H.Anchor && Object(V.a)(e.anchor.distanceToViewportTop)) {
                        const {anchor: t} = e, o = this._getDocumentViewportHeight(), n = t.distanceToViewportTop || 0,
                            r = i.findIndex((e => e.id === t.id));
                        let h = n, a = r;
                        for (; a > -1 && a < i.length && h < o;) {
                            const t = i[a], e = this._heights.get(t.id);
                            if (!Object(V.a)(e)) break;
                            s.push(new lt(t.id, h, !0, t.canBeAnchor)), h += e, a += 1
                        }
                        for (h = n, a = r - 1; a > -1 && h > 0;) {
                            const t = i[a], e = this._heights.get(t.id);
                            if (!Object(V.a)(e)) break;
                            h -= e, s.unshift(new lt(t.id, h, !0, t.canBeAnchor)), a -= 1
                        }
                    }
                    return s
                }, this._getViewportOffsetCorrection = () => {
                    const t = this._rootRef.current && this._rootRef.current.getBoundingClientRect();
                    if (!t || !this._viewport) return 0;
                    const e = this._viewport instanceof m.a ? 0 : this._viewport.getRect().getTop();
                    return _t({cssPixels: t.top - e, dpr: this._devicePixelRatio})
                }, this.getAnchors = () => {
                    const t = this._rootRef.current && this._rootRef.current.getBoundingClientRect(),
                        e = this._measureRelativeViewportRect();
                    return t && e ? this._getItemsWithin(e).filter((t => t.item.canBeAnchor)).map((t => ({
                        id: t.item.id,
                        distanceToViewportTop: _t({
                            cssPixels: t.offset + this._getViewportOffsetCorrection(),
                            dpr: this._devicePixelRatio
                        }),
                        wasFocused: this._hasUserChangedFocus && t.item.id === this._activeEntryId
                    }))) : []
                }, this._update = () => {
                    const t = this._measureRelativeViewportRect();
                    if (!t) return;
                    if (this._isFullScreened) return;
                    const e = this._getAnchor(t);
                    this._measureHeights(), e && (this._updateRenderedItems(e, t), this._areAnchorsInvalidated = !1)
                }, this._getItemsWithPositions = t => {
                    const {list: e} = this.props, i = this._getDistanceFromTop(t.itemId);
                    let s = t.offset - i;
                    const o = [];
                    return e.forEach((t => {
                        const e = this._getHeight(t);
                        o.push(new lt(t.id, s, this._heights.has(t.id), t.canBeAnchor, e)), s += e
                    })), o
                }, this._getSliceForCandidates = (t, e) => {
                    const i = Object(M.a)(t), s = Object(B.a)(t);
                    return {start: i ? e.indexOf(i) : 0, end: s ? e.indexOf(s) + 1 : 0}
                }, this._getRenderCandidates = (t, e) => {
                    const {minimumOffscreenToViewportRatio: i, preferredOffscreenToViewportRatio: s} = this.props,
                        o = It(e, i), n = It(e, s), r = this._isIdle && !this._isInitialAnchoring,
                        h = this._getItemsWithPositions(t),
                        a = h.filter((t => this._getRenderedItemRectInViewport(t).doesIntersectWith(r ? n : o))),
                        d = this._getSliceForCandidates(a, h), c = ((t, e, i) => {
                            if (i) return e;
                            if (e.start >= t.start && e.end <= t.end && t.end - t.start <= 50) return t;
                            if (e.start >= t.end || e.end <= t.start) return e;
                            {
                                const i = Math.max(t.start - e.start, e.end - t.end, 0);
                                return {start: Math.min(t.start + i, e.start), end: Math.max(t.end - i, e.end)}
                            }
                        })(this._slice, d, r), l = h.slice(c.start, c.end);
                    return {allItemsWithPositions: h, newRenderedItems: l, slice: c, arePreferredItemsRendered: r}
                }, this._getIsHeightsReady = t => Object(U.a)(t, (({itemId: t}) => this._heights.has(t))), this._getHeightBetweenItems = (t, e) => t && e ? this._getRenderedItemRectInViewport(e).getBottom() - this._getRenderedItemRectInViewport(t).getTop() : 0, this._getRenderedItemRectInViewport = t => t.getRectInViewport(), this._updateRenderedItems = (t, e) => {
                    const {
                            allItemsWithPositions: i,
                            arePreferredItemsRendered: s,
                            newRenderedItems: o,
                            slice: n
                        } = this._getRenderCandidates(t, e), r = 0 !== this._cellAnimations.size,
                        h = this._shouldNormalize(t), a = Object(M.a)(i), d = Object(B.a)(i),
                        c = this._getHeightBetweenItems(a, d), l = c + this._calculateHeadroom(i, e),
                        m = this._getIsHeightsReady(o), _ = !(D.b.isSafari() || D.b.isIOS()),
                        u = !r && m && (this._isIdle || _ || l <= e.getHeight()) || m && this._isInitialAnchoring;
                    let p = o;
                    if (this._slice = n, m && (this._isInitialAnchoring = !1), h && u) {
                        const {offset: i, renderedItems: s} = this._normalization(t, o);
                        p = s, this.setState({renderedItems: s, listHeightWithHeadroom: l, shouldAnimate: !h}, (() => {
                            let t = e;
                            0 !== i && (this._viewport.scrollBy(-i), t = this._measureRelativeViewportRect()), t && this._updatePositioning({
                                renderedItems: p,
                                relativeViewportRect: t,
                                firstItem: a,
                                newListHeight: c
                            })
                        }))
                    } else this.setState({renderedItems: o, listHeightWithHeadroom: l, shouldAnimate: !0}, (() => {
                        !h && s || this._scheduleUpdateDebounced(), this._updatePositioning({
                            renderedItems: p,
                            relativeViewportRect: e,
                            firstItem: a,
                            newListHeight: c
                        })
                    }))
                }, this._updatePositioning = ({
                                                  firstItem: t,
                                                  newListHeight: e,
                                                  relativeViewportRect: i,
                                                  renderedItems: s
                                              }) => {
                    const {list: o, onPositionUpdate: n} = this.props;
                    if (this._getIsHeightsReady(s)) {
                        const r = t ? this._getRenderedItemRectInViewport(t).getTop() : 0;
                        n(new dt({
                            viewportRect: i,
                            listRect: new G.a(r, e),
                            listLength: o.length,
                            renderedItems: s.map((t => ({
                                id: t.itemId,
                                rectangle: new G.a(t.offset, this._getHeightForItemId(t.itemId))
                            })))
                        }))
                    }
                }, this._shouldNormalize = t => this.props.hasNewContentAtBottom ? this._getListOffset(t) - this._currentHeadroom != 0 : 0 !== this._getListOffset(t), this._normalization = (t, e) => {
                    const i = this._getListOffset(t);
                    return {
                        offset: i,
                        renderedItems: e.map((t => new lt(t.itemId, t.offset - i, t.visible, t.canBeAnchor)))
                    }
                }, this._calculateHeadroom = (t, e) => this.props.withoutHeadroom ? (this._currentHeadroom = 0, this._currentHeadroom) : this.props.centerInitialAnchor ? this._calculateTopHeadroom(t, e) + this._calculateBottomHeadroom(t, e) : this.props.hasNewContentAtBottom ? this._calculateTopHeadroom(t, e) : this._calculateBottomHeadroom(t, e), this._calculateBottomHeadroom = (t, e) => {
                    const i = Object(j.a)(t, (t => t.canBeAnchor)), s = Object(B.a)(t);
                    if (!s) return this._currentHeadroom = 0, this._currentHeadroom;
                    const o = this._getRenderedItemRectInViewport(s),
                        n = o.getBottom() - (i ? this._getRenderedItemRectInViewport(i).getTop() : o.getTop());
                    return this._currentHeadroom = Math.max(0, e.getHeight() - n + this._viewport.getOffsetBottom()), this._currentHeadroom
                }, this._calculateTopHeadroom = (t, e) => {
                    const i = Object(j.a)(t, (t => t.canBeAnchor)), s = Object(M.a)(t);
                    if (!s) return this._currentHeadroom = 0, this._currentHeadroom;
                    const o = this._getRenderedItemRectInViewport(s),
                        n = (i ? this._getRenderedItemRectInViewport(i).getBottom() : o.getBottom()) - o.getTop(),
                        r = this._getDocumentViewportHeight() - e.getHeight();
                    return this._currentHeadroom = Math.max(0, e.getHeight() - n - r), this._currentHeadroom
                }, this._getListOffset = t => {
                    if (!t) return this.props.hasNewContentAtBottom ? this._currentHeadroom : 0;
                    const e = this._getDistanceFromTop(t.itemId);
                    return this.props.hasNewContentAtBottom ? t.offset - e - this._currentHeadroom : t.offset - e
                }, this._getAnchorItemCandidates = () => {
                    const {analytics: t} = this.props, e = this._getFinalRenderedItems(),
                        i = e.filter((({item: t}) => t.canBeAnchor && (this._isInitialAnchoring || !!this._heights.get(t.id))));
                    if (this._areAnchorsInvalidated) {
                        const i = e.filter((({item: t}) => {
                            var e;
                            const i = null == (e = this._previousItemMap.get(t.id)) ? void 0 : e.sortIndex;
                            return i === W.a || t.sortIndex === W.a || i === t.sortIndex
                        }));
                        if (i.length !== e.length) return t.scribe({
                            element: "scroller",
                            action: "hoisted_anchor_invalidation"
                        }), i;
                        t.scribe({element: "scroller", action: "no_hoisted_anchor_invalidation"})
                    }
                    return i
                }, this._shouldPinToNewest = () => !this._isInitialAnchoring && !!this.props.pinToNewestWhenAtNewest && this.isAtNewest(), this._getAnchor = t => {
                    if (this._shouldPinToNewest() && !this.props.centerInitialAnchor) {
                        if (this.props.hasNewContentAtBottom) {
                            const t = Object(B.a)(this.state.renderedItems);
                            return t ? {itemId: t.itemId, offset: t.offset} : void 0
                        }
                        {
                            const t = Object(M.a)(this.props.list);
                            return t ? {itemId: t.id, offset: 0} : void 0
                        }
                    }
                    const e = e => {
                        const i = Object(G.b)(e, t);
                        return (e.getHeight() > 0 ? i / e.getHeight() : 0) > .01 ? 1 : 0
                    }, i = e => e.getBottom() - t.getTop(), s = this._getAnchorItemCandidates(), o = gt(s, ((t, s) => {
                        const o = new lt(t.item.id, t.offset, t.visible, !0, this._getHeight(t.item)).getRectInViewport(),
                            n = new lt(s.item.id, s.offset, s.visible, !0, this._getHeight(s.item)).getRectInViewport();
                        return this.props.hasNewContentAtBottom ? e(o) - e(n) || Math.abs(i(o)) - Math.abs(i(n)) : e(o) - e(n) || Math.abs(i(n)) - Math.abs(i(o))
                    }));
                    if (o) return {itemId: o.item.id, offset: o.offset};
                    const n = Object(M.a)(s);
                    if (n) return {itemId: n.item.id, offset: n.offset};
                    {
                        const t = Object(M.a)(this.props.list);
                        return t ? {itemId: t.id, offset: 0} : void 0
                    }
                }, this._measureRelativeViewportRect = () => {
                    const t = this._rootRef.current;
                    if (t) return this._viewport.getRect().translateBy(-t.getBoundingClientRect().top)
                }, this._getHeight = t => {
                    var e;
                    return this._getHeightForItemId(t.id, null == (e = t.data) ? void 0 : e.type)
                }, this._getHeightForItemId = (t, e = "") => {
                    const {assumedItemHeight: i} = this.props, s = this._heights.get(t),
                        o = Object(V.a)(s) ? s : "function" == typeof i ? i(e) : i;
                    return _t({cssPixels: o, dpr: this._devicePixelRatio})
                }, this._getDistanceFromTop = t => {
                    const {list: e} = this.props, i = e.findIndex((e => e.id === t));
                    return i >= 0 ? e.slice(0, i).reduce(((t, e) => this._getHeight(e) + t), 0) : 0
                }, this._getItemsWithin = t => this._getFinalRenderedItems().filter((({
                                                                                          item: e,
                                                                                          offset: i
                                                                                      }) => new G.a(i, this._getHeight(e)).doesIntersectWith(t))), this._measureHeights = () => {
                    this._cells.forEach(((t, e) => {
                        this._heights.set(e, t.measureHeight())
                    }))
                }, this._handleAnimationStarted = (t, e) => {
                    this._cellAnimations.add(t), e && (this._cellAnimationStyle = e)
                }, this._handleAnimationEnded = t => {
                    this._cellAnimations.delete(t), this._cellAnimationStyle = st
                }, this._handleItemVisible = (t, e) => {
                    this._visibilityMeasurements.has(t) || this._visibilityMeasurements.set(t, e)
                }, this._reportVisibilityMeasurements = () => {
                    if (!this._visibilityMeasurements.size) return;
                    let t = 0;
                    this._visibilityMeasurements.forEach((e => t += e));
                    const e = Math.round(t / this._visibilityMeasurements.size),
                        i = D.b.isDesktopOS() ? "scroller_v3" : "scroller_v3_mobile";
                    J.c(`scroller:ttfv:${i}`, {duration_ms: e}), this._visibilityMeasurements.clear()
                }, this._updateItemHeight = (t, e) => {
                    this._pendingHeightUpdates.set(t, e);
                    (Object(U.a)(this.state.renderedItems, (({itemId: t}) => this._heights.has(t) || this._pendingHeightUpdates.has(t))) || this._pendingHeightUpdates.size > 50) && (this._update(), this._pendingHeightUpdates.clear())
                }, this._handleHeightChanged = (t, e, i = !1) => {
                    this._heights.get(t) !== e && (this._cellAnimations.has(t) ? this._scheduleCriticalUpdate() : this._updateItemHeight(t, e))
                }, this._setItemRef = (t, e) => {
                    e ? (this._cells.set(t, e), this._renderedItemsStatus.add(t)) : (this._cells.delete(t), this._renderedItemsStatus.delete(t))
                }, this._getRenderedItemsWithFocusability = () => this._getFinalRenderedItems().map((({
                                                                                                          item: t,
                                                                                                          visible: e
                                                                                                      }) => {
                    const i = this._cells.get(t.id);
                    return {id: t.id, focusable: !(!i || !i.isFocusable()), visible: e}
                })), this._findNewestVisibleId = () => {
                    const t = this._measureRelativeViewportRect(), e = t && this._getFinalRenderedItems().find((({
                                                                                                                     item: e,
                                                                                                                     offset: i
                                                                                                                 }) => new G.a(i, this._getHeight(e)).doesIntersectWith(t)));
                    return e && e.item.id
                }, this.adjustFocusBy = t => {
                    this._hasUserChangedFocus = !0;
                    const e = this._getRenderedItemsWithFocusability();
                    let i = this._activeEntryId && ((t, e, i) => {
                        const s = t ? Object(ht.a)(i, (e => e.id === t)) : -1;
                        if (s >= 0) for (let t = s >= 0 ? s + e : 0; t >= 0 && t < i.length; t += e) if (i[t].focusable) return i[t].id;
                        return s >= 0 ? t : void 0
                    })(this._activeEntryId, t, e);
                    if (!i) {
                        const t = this._findNewestVisibleId();
                        i = t ? ((t, e) => {
                            const i = Object(ht.a)(e, (e => e.id === t));
                            let s;
                            if (i >= 0) {
                                const t = e.find(((t, e) => e >= i && t.focusable));
                                s = t ? t.id : void 0
                            }
                            return s || at(e)
                        })(t, e) : at(e)
                    }
                    i && this._updateFocusToItem(i)
                }, this._updateFocusToItem = (t, e) => {
                    if (t !== this._activeEntryId) {
                        const i = this._getRenderedItemsWithFocusability().find((e => e.visible && e.id === t)),
                            s = this._cells.get(t), o = s && s.getElement();
                        i && (this._activeEntryId = t, o && ((t, e, i) => {
                            const s = rt.a.findDOMNode(t),
                                o = s && s instanceof window.HTMLElement && s.querySelector("a, [tabindex='0']");
                            if (o) {
                                o.scrollIntoView(i), o.focus();
                                const t = (e || m.a.root()).getRect().getTop();
                                t > 0 && window.scrollBy(0, -1 * t)
                            }
                        })(o, this.context.viewport, e))
                    }
                }, this.scrollToNewest = t => {
                    this._hasUserChangedFocus = !0, this.props.hasNewContentAtBottom ? this._viewport.scrollTo(0, this.state.listHeightWithHeadroom) : this._viewport.scrollToTop(), t && (this._update(), E()((() => {
                        const t = this._getRenderedItemsWithFocusability(), e = at(t);
                        e && this._updateFocusToItem(e, {block: "nearest"})
                    })))
                }, this.isAtNewest = () => {
                    const t = this._measureRelativeViewportRect();
                    return !t || (this.props.hasNewContentAtBottom ? t.getBottom() >= this.state.listHeightWithHeadroom - 50 : t.getTop() <= 50)
                }, this._viewport = t.viewport, this._devicePixelRatio = window.devicePixelRatio || 1, this.state = {
                    renderedItems: [],
                    listHeightWithHeadroom: 0,
                    shouldAnimate: !1
                };
                const {cacheKey: i, initialAnchor: s} = this.props;
                i && mt.hasOwnProperty(i) ? this._heights = mt[i] : (this._heights = new Map, mt[i] = this._heights), this._scheduleCriticalUpdate = Object(O.a)((() => this._update()), window.requestAnimationFrame), this._scheduleUpdate = window.requestIdleCallback ? Object(O.a)((() => {
                    this._update()
                }), window.requestIdleCallback) : this._scheduleCriticalUpdate, this._scheduleCriticalUpdateThrottled = Object(a.a)((() => {
                    this._scheduleCriticalUpdate()
                }), 100, {trailing: !0}), this._scheduleUpdateDebounced = Object(N.a)(this._scheduleUpdate, 250), this._wasPreviouslyAtNewestEnd = !s, this._removeViewportResizeHandler = this._viewport.addRectChangeListener(this._scheduleCriticalUpdateThrottled), this._shouldUseTopPositioning = this.context.featureSwitches.isTrue("responsive_web_scroller_top_positioning_enabled") || D.b.isMobileOS() && D.b.isSafari(), window.scroller = this
            }

            render() {
                const {listHeightWithHeadroom: t, renderedItems: e, shouldAnimate: i} = this.state,
                    s = this._getIsHeightsReady(e);
                return o.a.createElement(ct.a.Provider, {value: this._getPositioningContext(s)}, o.a.createElement("div", {
                    ref: this._rootRef,
                    style: {position: "relative", minHeight: t}
                }, this._getFinalRenderedItems().map((({item: t, offset: e, visible: s}) => {
                    const n = {
                        top: this._shouldUseTopPositioning ? `${e}px` : void 0,
                        transform: this._shouldUseTopPositioning ? void 0 : `translateY(${e}px)`
                    };
                    return o.a.createElement(ot, {
                        item: t,
                        key: t.id,
                        onAnimationEnded: this._handleAnimationEnded,
                        onAnimationStarted: this._handleAnimationStarted,
                        onHeightChanged: this._handleHeightChanged,
                        onVisible: this._handleItemVisible,
                        positioningStyle: n,
                        setAPI: this._setItemRef,
                        shouldAnimate: i,
                        translationTransitionStyle: this._cellAnimationStyle,
                        visible: s
                    })
                }))))
            }

            shouldComponentUpdate(t, e) {
                return !P()(this.props, t) || !Object(L.a)(this.state, e)
            }

            componentDidUpdate(t, e) {
                t.list !== this.props.list && (this._isInitialAnchoring || (this._previousItemMap = new Map, t.list.forEach((t => {
                    this._previousItemMap.set(t.id, t)
                })), this._areAnchorsInvalidated = !0, this._shouldPinToNewest() && t.list.length !== this.props.list.length && this.props.analytics.scribe({
                    element: "scroller",
                    action: "pin_to_top_attempt"
                })), this._scheduleCriticalUpdate()), t.cacheKey !== this.props.cacheKey && (this._hasUserChangedFocus = !1), this._wasPreviouslyAtNewestEnd && this.props.list.find((t => t.id === Z.a)) && this._getHeightForItemId(Z.a) > 0 && !this.props.centerInitialAnchor && this.scrollToNewest()
            }

            componentDidMount() {
                var t;
                this._removeScrollHandler = this._viewport.addScrollListener(this._handleScroll), this._removeProgrammaticScrollHandler = this._viewport.addProgrammaticScrollListener(this._handleProgrammaticScroll), this._removeFullscreenEnterHandler = (t = this._handleEnterFullscreen, Y || $(), K.add(t), () => K.delete(t)), this._removeFullscreenExitHandler = (t => (Y || $(), q.add(t), () => q.delete(t)))(this._handleExitFullscreen);
                const e = this._getInitialRenderedItems();
                if (this.props.isManualScrollRestoration && this._viewport.scrollBy(-1), this._isInitialAnchoring = !0, e.length > 0) {
                    const t = this._getDocumentViewportHeight();
                    this.setState({renderedItems: e, shouldAnimate: !0, listHeightWithHeadroom: t}, (() => {
                        const {initialAnchor: t} = this.props;
                        if (t && t.type === H.Anchor) this._viewport.scrollBy(this._getViewportOffsetCorrection()), t.anchor.wasFocused && this._updateFocusToItem(t.anchor.id); else if (t && t.type === H.FocusedItem) {
                            const e = this.props.centerInitialAnchor ? {behavior: "smooth", block: "center"} : void 0;
                            this._updateFocusToItem(t.itemId, e)
                        }
                        window.requestAnimationFrame((() => window.requestAnimationFrame((() => this._scheduleCriticalUpdate()))))
                    }))
                } else this._update()
            }

            componentWillUnmount() {
                this._removeScrollHandler && this._removeScrollHandler(), this._removeProgrammaticScrollHandler && this._removeProgrammaticScrollHandler(), this._removeFullscreenEnterHandler && this._removeFullscreenEnterHandler(), this._removeFullscreenExitHandler && this._removeFullscreenExitHandler(), this._removeViewportResizeHandler && this._removeViewportResizeHandler(), this._reportVisibilityMeasurements()
            }

            _getDocumentViewportHeight() {
                var t;
                return (null == (t = document.documentElement) ? void 0 : t.clientHeight) || 0
            }

            _getFinalRenderedItems() {
                const {list: t} = this.props, {renderedItems: e} = this.state;
                return this._getFinalRenderedItemsMemoized(t, e)
            }
        }

        ut.contextType = z.a, ut.defaultProps = {
            centerInitialAnchor: !1,
            nearEndProximityRatio: 1.75,
            nearStartProximityRatio: .25,
            assumedItemHeight: 400,
            hasNewContentAtBottom: !1,
            minimumOffscreenToViewportRatio: .5,
            preferredOffscreenToViewportRatio: 2.5
        };
        var pt = Object(Q.a)(ut);
        const gt = (t, e) => {
            if (t.length) return t.reduce(((t, i) => e(i, t) > 0 ? i : t))
        }, It = (t, e) => {
            const i = e * t.getHeight();
            return new G.a(t.getTop() - i, t.getHeight() + 2 * i)
        };
        let ft;
        const wt = () => {
            ft = !1
        };

        class vt extends o.a.PureComponent {
            constructor(t, e) {
                super(t, e), this._renderer = o.a.createRef(), this._isModal = !1, this._getList = Object(h.a)(((t, e, i, s, o, n, r) => {
                    const h = [];
                    return t && h.push(Object(R.a)("$header", "header", (() => t), !0)), h.push(...i.map((t => Object(R.a)(n(t), t, s, !o || o(t), r && r(t))))), e && h.push(Object(R.a)("$footer", "footer", (() => e), !1)), h
                })), this._render = ({isModal: t}) => {
                    const {
                        anchoring: e,
                        assumedItemHeight: i,
                        cacheKey: s,
                        canBeAnchorFunction: n,
                        centerInitialAnchor: r,
                        footer: h,
                        hasNewContentAtBottom: a,
                        header: d,
                        identityFunction: c,
                        initialAnchor: m,
                        items: u,
                        renderer: p,
                        sortIndexFunction: g,
                        withKeyboardShortcuts: I,
                        withoutHeadroom: f
                    } = this.props, w = this._scrollRestorationAnchor[s], v = w ? T(w) : m ? y(m.id) : void 0;
                    return t && (this._isModal = !0, ft = !0), o.a.createElement(_.a, {
                        enabled: I,
                        handlers: {
                            [l.e.refresh]: this._handleKeyboardRefresh,
                            [l.e.nextItem]: this._handleKeyboardFocusNext,
                            [l.e.previousItem]: this._handleKeyboardFocusPrevious
                        }
                    }, o.a.createElement(pt, {
                        assumedItemHeight: i,
                        cacheKey: s,
                        centerInitialAnchor: r,
                        hasNewContentAtBottom: a,
                        initialAnchor: v,
                        isManualScrollRestoration: window.history && "manual" === window.history.scrollRestoration,
                        key: s,
                        list: this._getList(d, h, u, p, n, c, g),
                        onPositionUpdate: this._handlePositionUpdate,
                        onScrollEnd: this._handleScrollEnd,
                        pinToNewestWhenAtNewest: e.pinToNewestWhenAtNewest,
                        ref: this._renderer,
                        viewport: this._viewport,
                        withoutHeadroom: f
                    }))
                }, this._handleScrollEnd = () => {
                    this.props.onScrollEnd && this.props.onScrollEnd()
                }, this._handlePositionUpdate = t => {
                    const {onItemsRendered: e} = this.props;
                    this._edgeProximity.handlePositioningUpdate(t), e && e({
                        positions: t.getRenderedItems(),
                        viewport: t.getForViewport()
                    }), this._preservePosition(this._customLocation)
                }, this._shouldPreventKeyboardShortcuts = () => ft && !this._isModal, this._handleKeyboardRefresh = Object(a.a)((() => {
                    const {onKeyboardRefresh: t} = this.props;
                    this._shouldPreventKeyboardShortcuts() || t && t()
                }), 1e3), this._handleKeyboardFocusNext = () => {
                    !this._shouldPreventKeyboardShortcuts() && this.adjustFocusBy(1)
                }, this._handleKeyboardFocusPrevious = () => {
                    !this._shouldPreventKeyboardShortcuts() && this.adjustFocusBy(-1)
                }, this.isAtNewest = () => !this._renderer.current || this._renderer.current.isAtNewest();
                const {nearEndProximityRatio: i, nearStartProximityRatio: s} = t;
                this._edgeProximity = new b([{
                    condition: p(5),
                    callback: t => this.props.onAtStart(t)
                }, {condition: I(s), callback: t => this.props.onNearStart(t)}, {
                    condition: f(i),
                    callback: t => this.props.onNearEnd(t)
                }, {
                    condition: g(5),
                    callback: t => this.props.onAtEnd(t)
                }]), this._viewport = t.viewport || this.context && this.context.viewport || m.a.root(), this._loadStoredPosition(t, this.context)
            }

            render() {
                const {items: t, noItemsRenderer: e} = this.props;
                return t.length ? o.a.createElement(r.b.Consumer, null, this._render) : e()
            }

            componentDidMount() {
                const {onPositionRestored: t} = this.props;
                t()
            }

            componentDidUpdate(t) {
                const {cacheKey: e, onPositionRestored: i} = this.props;
                e !== t.cacheKey && i()
            }

            UNSAFE_componentWillReceiveProps(t) {
                const {cacheKey: e} = this.props;
                e !== t.cacheKey && this._loadStoredPosition(t, this.context)
            }

            componentWillUnmount() {
                this._isModal && (ft = !1)
            }

            _preservePosition(t) {
                if (t && this._renderer.current) {
                    const e = this._renderer.current.getAnchors();
                    t.savePosition(e)
                }
            }

            _loadStoredPosition(t, e) {
                const {getCustomLocation: i} = e;
                this._customLocation = i && i();
                let s = [];
                if (this._customLocation) {
                    const t = this._customLocation.getSavedPosition();
                    s = t && t.length ? t : [], s.length > 0 && this._customLocation && this._customLocation.claimScrollRestoration()
                }
                const o = s.find((({
                                       id: e,
                                       wasFocused: i
                                   }) => i && t.items.some((i => t.identityFunction(i) === e)))) || s.find((({
                                                                                                                 distanceToViewportTop: e,
                                                                                                                 id: i
                                                                                                             }) => t.items.some((e => t.identityFunction(e) === i))));
                this._scrollRestorationAnchor = {[t.cacheKey]: o}
            }

            adjustFocusBy(t) {
                this._renderer.current && this._renderer.current.adjustFocusBy(t)
            }

            scrollToNewest(t) {
                this._renderer.current && this._renderer.current.scrollToNewest(t)
            }
        }

        vt.contextTypes = {viewport: n.object, getCustomLocation: n.func}, vt.defaultProps = {
            anchoring: A.a,
            centerInitialAnchor: !1,
            hasNewContentAtBottom: !1,
            onPositionRestored: d.a,
            onAtEnd: d.a,
            onAtStart: d.a,
            onNearEnd: d.a,
            onNearStart: d.a,
            onScrollEnd: d.a,
            nearEndProximityRatio: 1.75,
            nearStartProximityRatio: .25,
            noItemsRenderer: c.a,
            assumedItemHeight: 400,
            minimumOffscreenToViewportRatio: .5,
            preferredOffscreenToViewportRatio: 2.5,
            withoutHeadroom: !1,
            withKeyboardShortcuts: !1
        }
    }, ZIU7: function (t, e, i) {
        "use strict";
        i.d(e, "a", (function () {
            return o
        }));
        i("ERkP");

        class s {
            constructor(t, e, i, s, o) {
                this.id = t, this._renderer = i, this.canBeAnchor = s, this.data = e, this.sortIndex = o
            }

            render(t) {
                const {_renderer: e, data: i} = this;
                return e(i, t)
            }
        }

        const o = (t, e, i, o, n = "-1") => new s(t, e, i, o, n)
    }, gbD7: function (t, e, i) {
        "use strict";
        i.d(e, "b", (function () {
            return n
        })), i.d(e, "a", (function () {
            return r
        })), i.d(e, "d", (function () {
            return h
        })), i.d(e, "c", (function () {
            return a
        }));
        i("ERkP");
        var s = i("aWyx");
        const o = (t, e) => ({
                entry: {id: e, time: "", type: t},
                isActive: !1,
                isRapidFire: !1,
                isFirstRapidFire: !1,
                isLastPersistedMessage: !1,
                isLastRapidFire: !1,
                type: t
            }), n = o(s.b.CONVERSATION_PROFILE_INFO_HEADER, "conversationProfileInfoHeader"), r = "typingIndicator",
            h = o(s.b.TYPING_INDICATOR, r), a = o(s.b.READ_ONLY_INDICATOR, "readOnlyIndicator")
    }, jHwr: function (t, e, i) {
        "use strict";
        e.a = (t, e) => {
            let i = null;
            const s = () => {
                i = null, t()
            };
            return () => (i || (i = e(s)), i)
        }
    }, uySD: function (t, e, i) {
        "use strict";
        const s = Object.freeze({
            MOVEMENT: "movement",
            LIST_UPDATE: "list_update",
            INITIAL_POSITION: "initial_position"
        });
        e.a = s
    }
}]);
//# sourceMappingURL=https://ton.local.twitter.com/responsive-web-internal/sourcemaps/client-web/loader.AbsolutePower.de1403c8.js.map